// This file was automatically generated by CoreTweet.
// Do not modify this file directly.

// The MIT License (MIT)
//
// CoreTweet - A .NET Twitter Library supporting Twitter API 1.1
// Copyright (c) 2013-2015 CoreTweet Development Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using CoreTweet.Core;
#if !NET35
using System.Threading;
using System.Threading.Tasks;
#endif

namespace CoreTweet.Rest
{

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST account.
    /// </summary>
    public partial class Account : ApiProviderBase
    {
        internal Account (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings<T>(T parameters)
        {
            return this.Tokens.AccessApi<Setting, T>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Setting, T>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// </summary>
        /// <param name="device">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(string device, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(device == null) throw new ArgumentNullException("device");
            else parameters.Add("device", device);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// </summary>
        /// <param name="device">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(string device, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(device == null) throw new ArgumentNullException("device");
            else parameters.Add("device", device);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(string name = null, string url = null, string location = null, string description = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(string name = null, string url = null, string location = null, string description = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }
        #endif

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImageTile(bool tile, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageTileAsync(bool tile, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="use">required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImageUse(bool use, bool? tile = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("use", use);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="use">required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageUseAsync(bool use, bool? tile = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("use", use);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }
        #endif

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <returns></returns>
        public void RemoveProfileBanner()
        {
            var parameters = new Dictionary<string, object>();
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// </summary>
        /// <param name="profile_background_color">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="profile_sidebar_border_color">optional.</param>
        /// <param name="profile_sidebar_fill_color">optional.</param>
        /// <param name="profile_text_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(string profile_background_color = null, string profile_link_color = null, string profile_sidebar_border_color = null, string profile_sidebar_fill_color = null, string profile_text_color = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(profile_background_color != null) parameters.Add("profile_background_color", profile_background_color);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(profile_sidebar_border_color != null) parameters.Add("profile_sidebar_border_color", profile_sidebar_border_color);
            if(profile_sidebar_fill_color != null) parameters.Add("profile_sidebar_fill_color", profile_sidebar_fill_color);
            if(profile_text_color != null) parameters.Add("profile_text_color", profile_text_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// </summary>
        /// <param name="profile_background_color">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="profile_sidebar_border_color">optional.</param>
        /// <param name="profile_sidebar_fill_color">optional.</param>
        /// <param name="profile_text_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(string profile_background_color = null, string profile_link_color = null, string profile_sidebar_border_color = null, string profile_sidebar_fill_color = null, string profile_text_color = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(profile_background_color != null) parameters.Add("profile_background_color", profile_background_color);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(profile_sidebar_border_color != null) parameters.Add("profile_sidebar_border_color", profile_sidebar_border_color);
            if(profile_sidebar_fill_color != null) parameters.Add("profile_sidebar_fill_color", profile_sidebar_fill_color);
            if(profile_text_color != null) parameters.Add("profile_text_color", profile_text_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(Stream image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(FileInfo image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(Stream image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(FileInfo image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("image");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }
        #endif

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET application.
    /// </summary>
    public partial class Application : ApiProviderBase
    {
        internal Application (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus<T>(T parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(string resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns>The dictionary.</returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IEnumerable<string> resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(string resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The dictionary.</returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IEnumerable<string> resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST blocks.
    /// </summary>
    public partial class Blocks : ApiProviderBase
    {
        internal Blocks (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> Ids(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIds<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<long> EnumerateList(EnumerateMode mode, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST direct_messages.
    /// </summary>
    public partial class DirectMessages : ApiProviderBase
    {
        internal DirectMessages (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Received(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Received(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Received<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage, T>(MethodType.Get, "direct_messages", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Received(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> ReceivedAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage, T>(MethodType.Get, "direct_messages", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent to the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> ReceivedAsync(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Sent(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Sent(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Sent<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<DirectMessage, T>(MethodType.Get, "direct_messages/sent", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The direct messages.</returns>
        public ListedResponse<DirectMessage> Sent(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> SentAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> SentAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> SentAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<DirectMessage, T>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent direct messages sent by the authenticating user.</para>
        /// <para>Includes detailed information about the sender and recipient user.</para>
        /// <para>You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="page">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct messages.</returns>
        public Task<ListedResponse<DirectMessage>> SentAsync(long? since_id = null, long? max_id = null, int? count = null, int? page = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(page != null) parameters.Add("page", page);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<DirectMessage>(MethodType.Get, "direct_messages/sent", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse, T>(MethodType.Get, "direct_messages/show", parameters);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Show(long id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse, T>(MethodType.Get, "direct_messages/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a single direct message, specified by an id parameter.</para>
        /// <para>Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> ShowAsync(long id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Get, "direct_messages/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse New(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse New(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse New<T>(T parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse, T>(MethodType.Post, "direct_messages/new", parameters);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="text">required.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse New(long user_id, string text)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(text == null) throw new ArgumentNullException("text");
            else parameters.Add("text", text);
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="text">required.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse New(string screen_name, string text)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(text == null) throw new ArgumentNullException("text");
            else parameters.Add("text", text);
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> NewAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> NewAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>string</c> text (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> NewAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse, T>(MethodType.Post, "direct_messages/new", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="text">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> NewAsync(long user_id, string text, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(text == null) throw new ArgumentNullException("text");
            else parameters.Add("text", text);
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sends a new direct message to the specified user from the authenticating user.</para>
        /// <para>Requires both the user and text parameters and must be a POST.</para>
        /// <para>Returns the sent message in the requested format if successful.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Note: Either user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="text">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> NewAsync(string screen_name, string text, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(text == null) throw new ArgumentNullException("text");
            else parameters.Add("text", text);
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/new", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<DirectMessageResponse, T>(MethodType.Post, "direct_messages/destroy", parameters);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The direct message.</returns>
        public DirectMessageResponse Destroy(long id, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<DirectMessageResponse, T>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Destroys the direct message specified in the required ID parameter.</para>
        /// <para>The authenticating user must be the recipient of the specified direct message.</para>
        /// <para>This method requires an access token with RWD (read, write and direct message) permissions.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The direct message.</returns>
        public Task<DirectMessageResponse> DestroyAsync(long id, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<DirectMessageResponse>(MethodType.Post, "direct_messages/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST favorites.
    /// </summary>
    public partial class Favorites : ApiProviderBase
    {
        internal Favorites (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "favorites/list", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// </summary>
        /// <param name="id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> List(long? id = null, string screen_name = null, int? count = null, long? since_id = null, long? max_id = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id != null) parameters.Add("id", id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "favorites/list", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (optional)</para>
        /// <para>- <c>string</c> screen_name (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "favorites/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent Tweets favorited by the authenticating or specified user.</para>
        /// </summary>
        /// <param name="id">optional.</param>
        /// <param name="screen_name">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> ListAsync(long? id = null, string screen_name = null, int? count = null, long? since_id = null, long? max_id = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id != null) parameters.Add("id", id);
            if(screen_name != null) parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "favorites/list", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<StatusResponse, T>(MethodType.Post, "favorites/create", parameters);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The favorited status.</returns>
        public StatusResponse Create(long id, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse, T>(MethodType.Post, "favorites/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the favorite status when successful.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The favorited status.</returns>
        public Task<StatusResponse> CreateAsync(long id, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<StatusResponse, T>(MethodType.Post, "favorites/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(long id, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "favorites/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse, T>(MethodType.Post, "favorites/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-favorites the status specified in the ID parameter as the authenticating user.</para>
        /// <para>Returns the un-favorited status in the requested format when successful.</para>
        /// <para>This process invoked by this method is asynchronous.</para>
        /// <para>The immediately returned status may not indicate the resultant favorited status of the tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(long id, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "favorites/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET followers.
    /// </summary>
    public partial class Followers : ApiProviderBase
    {
        internal Followers (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored<long>.Enumerate(this.Tokens, "followers/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored<long>.Enumerate(this.Tokens, "followers/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "followers/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "followers/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "followers/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "followers/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long user_id, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(string screen_name, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "followers/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>, T>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, long user_id, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return Cursored<User>.Enumerate(this.Tokens, "followers/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long user_id, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string screen_name, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return Cursored<User>.Enumerate(this.Tokens, "followers/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string screen_name, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "followers/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "followers/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "followers/list", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>, T>(MethodType.Get, "followers/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long user_id, long? cursor = null, bool? skip_status = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for users following the specified user.</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string screen_name, long? cursor = null, bool? skip_status = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "followers/list", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET friends.
    /// </summary>
    public partial class Friends : ApiProviderBase
    {
        internal Friends (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored<long>.Enumerate(this.Tokens, "friends/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(long user_id, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return Cursored<long>.Enumerate(this.Tokens, "friends/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Ids(string screen_name, long? cursor = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friends/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friends/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIds<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friends/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "friends/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(long user_id, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first; however this ordering is subject to unannounced change and eventual consistency issues.</para>
        /// <para>Results are given in groups of 5,000 user IDs and multiple "pages" of results can be navigated through using the next_cursor value in subsequent requests.</para>
        /// <para>This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IdsAsync(string screen_name, long? cursor = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friends/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>, T>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, long user_id, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return Cursored<User>.Enumerate(this.Tokens, "friends/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long user_id, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string screen_name, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return Cursored<User>.Enumerate(this.Tokens, "friends/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string screen_name, long? cursor = null, bool? skip_status = null, int? count = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "friends/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "friends/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "friends/list", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>, T>(MethodType.Get, "friends/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long user_id, long? cursor = null, bool? skip_status = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").</para>
        /// <para>At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. </para>
        /// <para>Results are given in groups of 20 users and multiple “pages” of results can be navigated through using the next_cursor value in subsequent requests. </para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string screen_name, long? cursor = null, bool? skip_status = null, int? count = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(count != null) parameters.Add("count", count);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "friends/list", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST friendships.
    /// </summary>
    public partial class Friendships : ApiProviderBase
    {
        internal Friendships (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetIds(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetIds(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetIds<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<long, T>(MethodType.Get, "friendships/no_retweets/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// </summary>
        /// <returns>The IDs.</returns>
        public ListedResponse<long> NoRetweetIds()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<long>(MethodType.Get, "friendships/no_retweets/ids", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetIdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetIdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetIdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<long, T>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user_ids that the currently authenticated user does not want to receive retweets from.</para>
        /// <para>Use POST friendships/update to set the "no retweets" status for a given user account on behalf of the current user.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<ListedResponse<long>> NoRetweetIdsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<long>(MethodType.Get, "friendships/no_retweets/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "friendships/incoming", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateIncoming(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "friendships/incoming", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Incoming(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/incoming", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/incoming", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateIncoming<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/incoming", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "friendships/incoming", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every user who has a pending request to follow the authenticating user.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> IncomingAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/incoming", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "friendships/outgoing", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "friendships/outgoing", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> Outgoing(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/outgoing", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/outgoing", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateOutgoing<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "friendships/outgoing", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> OutgoingAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "friendships/outgoing", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Friendship, T>(MethodType.Get, "friendships/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The friendships.</returns>
        public ListedResponse<Friendship> Lookup(IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArray<Friendship>(MethodType.Get, "friendships/lookup", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Friendship, T>(MethodType.Get, "friendships/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided.</para>
        /// <para>Values for connections can be: following, following_requested, followed_by, none.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The friendships.</returns>
        public Task<ListedResponse<Friendship>> LookupAsync(IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArrayAsync<Friendship>(MethodType.Get, "friendships/lookup", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<Relationship, T>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(long source_id, long target_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(long source_id, string target_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            else parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(string source_screen_name, long target_id)
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            else parameters.Add("source_screen_name", source_screen_name);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <returns>The relationship.</returns>
        public Relationship Show(string source_screen_name, string target_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            else parameters.Add("source_screen_name", source_screen_name);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            else parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApi<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> source_id (any one is required)</para>
        /// <para>- <c>string</c> source_screen_name (any one is required)</para>
        /// <para>- <c>long</c> target_id (any one is required)</para>
        /// <para>- <c>string</c> target_screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship, T>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(long source_id, long target_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_id">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(long source_id, string target_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("source_id", source_id);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            else parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(string source_screen_name, long target_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            else parameters.Add("source_screen_name", source_screen_name);
            parameters.Add("target_id", target_id);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns detailed information about the relationship between two arbitrary users.</para>
        /// <para>Note: At least one source and one target, whether specified by IDs or screen_names, should be provided to this method.</para>
        /// </summary>
        /// <param name="source_screen_name">any one is required.</param>
        /// <param name="target_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> ShowAsync(string source_screen_name, string target_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(source_screen_name == null) throw new ArgumentNullException("source_screen_name");
            else parameters.Add("source_screen_name", source_screen_name);
            if(target_screen_name == null) throw new ArgumentNullException("target_screen_name");
            else parameters.Add("target_screen_name", target_screen_name);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Get, "friendships/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "friendships/create", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(long user_id, bool? follow = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(follow != null) parameters.Add("follow", follow);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Create(string screen_name, bool? follow = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(follow != null) parameters.Add("follow", follow);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> follow (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "friendships/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? follow = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(follow != null) parameters.Add("follow", follow);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating users to follow the user specified in the ID parameter.</para>
        /// <para>Returns the befriended user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="follow">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? follow = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(follow != null) parameters.Add("follow", follow);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "friendships/destroy", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse Destroy(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "friendships/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "friendships/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows the authenticating user to unfollow the user specified in the ID parameter.</para>
        /// <para>Returns the unfollowed user in the requested format when successful.</para>
        /// <para>Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "friendships/destroy", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update<T>(T parameters)
        {
            return this.Tokens.AccessApi<Relationship, T>(MethodType.Post, "friendships/update", parameters);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(long user_id, bool? device = null, bool? retweets = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <returns>The relationship.</returns>
        public Relationship Update(string screen_name, bool? device = null, bool? retweets = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApi<Relationship>(MethodType.Post, "friendships/update", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> device (optional)</para>
        /// <para>- <c>bool</c> retweets (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Relationship, T>(MethodType.Post, "friendships/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(long user_id, bool? device = null, bool? retweets = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Allows one to enable or disable retweets and device notifications from the specified user.</para>
        /// <para>Note: Providing either screen_name or user_id is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="device">optional.</param>
        /// <param name="retweets">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The relationship.</returns>
        public Task<Relationship> UpdateAsync(string screen_name, bool? device = null, bool? retweets = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(device != null) parameters.Add("device", device);
            if(retweets != null) parameters.Add("retweets", retweets);
            return this.Tokens.AccessApiAsync<Relationship>(MethodType.Post, "friendships/update", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST geo.
    /// </summary>
    public partial class Geo : ApiProviderBase
    {
        internal Geo (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", parameters);
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// </summary>
        /// <param name="place_id">required.</param>
        /// <returns>The place.</returns>
        public PlaceResponse Id(string place_id)
        {
            var parameters = new Dictionary<string, object>();
            if(place_id == null) throw new ArgumentNullException("place_id");
            else parameters.Add("place_id", place_id);
            return this.Tokens.AccessParameterReservedApi<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> place_id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Returns all the information about a known place.</para>
        /// </summary>
        /// <param name="place_id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The place.</returns>
        public Task<PlaceResponse> IdAsync(string place_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(place_id == null) throw new ArgumentNullException("place_id");
            else parameters.Add("place_id", place_id);
            return this.Tokens.AccessParameterReservedApiAsync<PlaceResponse>(MethodType.Get, "geo/id/{place_id}", "place_id", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces<T>(T parameters)
        {
            return this.Tokens.AccessApi<GeoResult, T>(MethodType.Get, "geo/similar_places", parameters, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="name">required.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="street_address">optional.</param>
        /// <returns>Places and the token</returns>
        public GeoResult SimilarPlaces(double lat, double @long, string name, string contained_within = null, string street_address = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(name == null) throw new ArgumentNullException("name");
            else parameters.Add("name", name);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            if(street_address != null) parameters.Add("street_address", street_address);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/similar_places", parameters, "result");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// <para>- <c>string</c> street_address (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult, T>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Locates places near the given coordinates which are similar in name.</para>
        /// <para>Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to POST geo/place to create a new one.</para>
        /// <para>The token contained in the response is the token needed to be able to create a new place.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="name">required.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="street_address">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places and the token</returns>
        public Task<GeoResult> SimilarPlacesAsync(double lat, double @long, string name, string contained_within = null, string street_address = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(name == null) throw new ArgumentNullException("name");
            else parameters.Add("name", name);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            if(street_address != null) parameters.Add("street_address", street_address);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/similar_places", parameters, cancellationToken, "result");
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult Search<T>(T parameters)
        {
            return this.Tokens.AccessApi<GeoResult, T>(MethodType.Get, "geo/search", parameters, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// </summary>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="query">optional.</param>
        /// <param name="ip">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="contained_within">optional.</param>
        /// <returns>Places.</returns>
        public GeoResult Search(double? lat = null, double? @long = null, string query = null, string ip = null, string granularity = null, string accuracy = null, int? max_results = null, string contained_within = null)
        {
            var parameters = new Dictionary<string, object>();
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(query != null) parameters.Add("query", query);
            if(ip != null) parameters.Add("ip", ip);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/search", parameters, "result");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> query (optional)</para>
        /// <para>- <c>string</c> ip (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// <para>- <c>string</c> contained_within (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult, T>(MethodType.Get, "geo/search", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.</para>
        /// <para>Note: At least one of the following parameters must be provided to this resource: lat, long, ip, or query</para>
        /// </summary>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="query">optional.</param>
        /// <param name="ip">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="contained_within">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> SearchAsync(double? lat = null, double? @long = null, string query = null, string ip = null, string granularity = null, string accuracy = null, int? max_results = null, string contained_within = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(query != null) parameters.Add("query", query);
            if(ip != null) parameters.Add("ip", ip);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(max_results != null) parameters.Add("max_results", max_results);
            if(contained_within != null) parameters.Add("contained_within", contained_within);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/search", parameters, cancellationToken, "result");
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode<T>(T parameters)
        {
            return this.Tokens.AccessApi<GeoResult, T>(MethodType.Get, "geo/reverse_geocode", parameters, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <returns>Places.</returns>
        public GeoResult ReverseGeocode(double lat, double @long, string accuracy = null, string granularity = null, int? max_results = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(max_results != null) parameters.Add("max_results", max_results);
            return this.Tokens.AccessApi<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, "result");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// <para>- <c>string</c> accuracy (optional)</para>
        /// <para>- <c>string</c> granularity (optional)</para>
        /// <para>- <c>int</c> max_results (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<GeoResult, T>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, "result");
        }

        /// <summary>
        /// <para>Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.</para>
        /// <para>This request is an informative call and will deliver generalized results about geography.</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="accuracy">optional.</param>
        /// <param name="granularity">optional.</param>
        /// <param name="max_results">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Places.</returns>
        public Task<GeoResult> ReverseGeocodeAsync(double lat, double @long, string accuracy = null, string granularity = null, int? max_results = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            if(accuracy != null) parameters.Add("accuracy", accuracy);
            if(granularity != null) parameters.Add("granularity", granularity);
            if(max_results != null) parameters.Add("max_results", max_results);
            return this.Tokens.AccessApiAsync<GeoResult>(MethodType.Get, "geo/reverse_geocode", parameters, cancellationToken, "result");
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET help.
    /// </summary>
    public partial class Help : ApiProviderBase
    {
        internal Help (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Configurations Configuration<T>(T parameters)
        {
            return this.Tokens.AccessApi<Configurations, T>(MethodType.Get, "help/configuration", parameters);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// </summary>
        /// <returns>Configurations.</returns>
        public Configurations Configuration()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<Configurations>(MethodType.Get, "help/configuration", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Configurations, T>(MethodType.Get, "help/configuration", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.</para>
        /// <para>It is recommended applications request this endpoint when they are loaded, but no more than once a day.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Configurations.</returns>
        public Task<Configurations> ConfigurationAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<Configurations>(MethodType.Get, "help/configuration", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Language, T>(MethodType.Get, "help/languages", parameters);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// </summary>
        /// <returns>Languages.</returns>
        public ListedResponse<Language> Languages()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<Language>(MethodType.Get, "help/languages", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Language, T>(MethodType.Get, "help/languages", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the list of languages supported by Twitter along with the language code supported by Twitter.</para>
        /// <para>The language code may be formatted as ISO 639-1 alpha-2 (en), ISO 639-3 alpha-3 (msa), or ISO 639-1 alpha-2 combined with an ISO 3166-1 alpha-2 localization (zh-tw).</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>Languages.</returns>
        public Task<ListedResponse<Language>> LanguagesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<Language>(MethodType.Get, "help/languages", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy<T>(T parameters)
        {
            return this.Tokens.AccessApi<StringResponse, T>(MethodType.Get, "help/privacy", parameters);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// </summary>
        /// <returns>The sentense.</returns>
        public StringResponse Privacy()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/privacy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse, T>(MethodType.Get, "help/privacy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns Twitter’s Privacy Policy.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> PrivacyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/privacy", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public StringResponse Tos<T>(T parameters)
        {
            return this.Tokens.AccessApi<StringResponse, T>(MethodType.Get, "help/tos", parameters);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// </summary>
        /// <returns>The sentense.</returns>
        public StringResponse Tos()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApi<StringResponse>(MethodType.Get, "help/tos", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StringResponse, T>(MethodType.Get, "help/tos", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the Twitter Terms of Service.</para>
        /// <para>Note: these are not the same as the Developer Policy.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sentense.</returns>
        public Task<StringResponse> TosAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiAsync<StringResponse>(MethodType.Get, "help/tos", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus<T>(T parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(string resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        [Obsolete("Use Application.RateLimitStatus.")]
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IEnumerable<string> resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> resources (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> resources (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(string resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IEnumerable<string> resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("resources");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists.
    /// </summary>
    public partial class Lists : ApiProviderBase
    {
        internal Lists (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<List, T>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(long user_id, bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <returns>The lists.</returns>
        public ListedResponse<List> List(string screen_name, bool? reverse = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArray<List>(MethodType.Get, "lists/list", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> reverse (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<List, T>(MethodType.Get, "lists/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(long user_id, bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns all lists the authenticating or specified user subscribes to, including their own.</para>
        /// <para>The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="reverse">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<ListedResponse<List>> ListAsync(string screen_name, bool? reverse = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(reverse != null) parameters.Add("reverse", reverse);
            return this.Tokens.AccessApiArrayAsync<List>(MethodType.Get, "lists/list", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>, T>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateMemberships(EnumerateMode mode, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateMemberships(EnumerateMode mode, long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateMemberships(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Memberships(string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateMemberships<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/memberships", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> filter_to_owned_lists (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>, T>(MethodType.Get, "lists/memberships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(long user_id, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists the specified user has been added to.</para>
        /// <para>If user_id or screen_name are not provided the memberships for the authenticating user are returned.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="filter_to_owned_lists">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> MembershipsAsync(string screen_name, int? count = null, long? cursor = null, bool? filter_to_owned_lists = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(filter_to_owned_lists != null) parameters.Add("filter_to_owned_lists", filter_to_owned_lists);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/memberships", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>, T>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Ownerships(string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateOwnerships<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/ownerships", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>, T>(MethodType.Get, "lists/ownerships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(long user_id, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the lists owned by the specified Twitter user.</para>
        /// <para>Private lists will only be shown if the authenticated user is also the owner of the lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> OwnershipsAsync(string screen_name, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/ownerships", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Show(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Get, "lists/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the specified list.</para>
        /// <para>Private lists will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> ShowAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Get, "lists/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<List>, T>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<List>.Enumerate(this.Tokens, "lists/subscriptions", mode, parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(long user_id, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<List>.Enumerate(this.Tokens, "lists/subscriptions", mode, parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <returns>The lists.</returns>
        public Cursored<List> Subscriptions(string screen_name, int? count = null, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/subscriptions", mode, parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/subscriptions", mode, parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The lists.</returns>
        public IEnumerable<List> EnumerateSubscriptions<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<List>.Enumerate(this.Tokens, "lists/subscriptions", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<List>, T>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(long user_id, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user’s own lists.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The lists.</returns>
        public Task<Cursored<List>> SubscriptionsAsync(string screen_name, int? count = null, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<List>>(MethodType.Get, "lists/subscriptions", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(long list_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(string slug, string owner_screen_name, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Statuses(string slug, long owner_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "lists/statuses", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(long list_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(string slug, string owner_screen_name, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a timeline of tweets authored by members of the specified list.</para>
        /// <para>Retweets are included by default. Use the <c>include_rts=false</c> parameter to omit retweets.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> StatusesAsync(string slug, long owner_id, long? since_id = null, long? max_id = null, int? count = null, bool? include_entities = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "lists/statuses", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/create", parameters);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string name, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            else parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (required)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Creates a new list for the authenticated user.</para>
        /// <para>Note that you can create up to 1000 lists per account.</para>
        /// </summary>
        /// <param name="name">required.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string name, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name == null) throw new ArgumentNullException("name");
            else parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The destroyed list.</returns>
        public ListResponse Destroy(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Deletes the specified list. The authenticated user must own the list to be able to destroy it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/destroy", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Update<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(long list_id, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(string slug, string owner_screen_name, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <returns>The list.</returns>
        public ListResponse Update(string slug, long owner_id, string name = null, string mode = null, string description = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> mode (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(long list_id, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(string slug, string owner_screen_name, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the specified list. The authenticated user must own the list to be able to update it.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="name">optional.</param>
        /// <param name="mode">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> UpdateAsync(string slug, long owner_id, string name = null, string mode = null, string description = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(name != null) parameters.Add("name", name);
            if(mode != null) parameters.Add("mode", mode);
            if(description != null) parameters.Add("description", description);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/update", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists/members.
    /// </summary>
    public partial class ListsMembers : ApiProviderBase
    {
        internal ListsMembers (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>, T>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/members", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>, T>(MethodType.Get, "lists/members", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the members of the specified list.</para>
        /// <para>Private list members will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/members", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a member of the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/members/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Add a member to a list. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists cannot have more than 5,000 members.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(long list_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(long list_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, string owner_screen_name, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, string owner_screen_name, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, long owner_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse CreateAll(string slug, long owner_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(long list_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(long list_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, string owner_screen_name, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, string owner_screen_name, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, long owner_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it.</para>
        /// <para>Note that lists can’t have more than 5,000 members, and you are limited to adding up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAllAsync(string slug, long owner_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/create_all", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id, long user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id, string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the specified member from the list. The authenticated user must be the list’s owner to remove members from the list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(long list_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(long list_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, string owner_screen_name, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, string owner_screen_name, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, long owner_id, IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse DestroyAll(string slug, long owner_id, IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(long list_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(long list_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, string owner_screen_name, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, string owner_screen_name, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, long owner_id, IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it.</para>
        /// <para>Note that lists can’t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.</para>
        /// <para>Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAllAsync(string slug, long owner_id, IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/members/destroy_all", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST lists/subscribers.
    /// </summary>
    public partial class ListsSubscribers : ApiProviderBase
    {
        internal ListsSubscribers (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>, T>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "lists/subscribers", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>, T>(MethodType.Get, "lists/subscribers", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long list_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, string owner_screen_name, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the subscribers of the specified list.</para>
        /// <para>Private list subscribers will only be shown if the authenticated user owns the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(string slug, long owner_id, int? count = null, long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(count != null) parameters.Add("count", count);
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "lists/subscribers", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long list_id, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, string owner_screen_name, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string slug, long owner_id, string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "lists/subscribers/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Create(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Subscribes the authenticated user to the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> CreateAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<ListResponse, T>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(long list_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, string owner_screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <returns>The list.</returns>
        public ListResponse Destroy(string slug, long owner_id)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApi<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> list_id (any one is required)</para>
        /// <para>- <c>string</c> slug (any one is required)</para>
        /// <para>- <c>string</c> owner_screen_name (any one is required)</para>
        /// <para>- <c>long</c> owner_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ListResponse, T>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="list_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(long list_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("list_id", list_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, string owner_screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(owner_screen_name == null) throw new ArgumentNullException("owner_screen_name");
            else parameters.Add("owner_screen_name", owner_screen_name);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Unsubscribes the authenticated user from the specified list.</para>
        /// </summary>
        /// <param name="slug">any one is required.</param>
        /// <param name="owner_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The list.</returns>
        public Task<ListResponse> DestroyAsync(string slug, long owner_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            parameters.Add("owner_id", owner_id);
            return this.Tokens.AccessApiAsync<ListResponse>(MethodType.Post, "lists/subscribers/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST mutes/users.
    /// </summary>
    public partial class MutesUsers : ApiProviderBase
    {
        internal MutesUsers (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "mutes/users/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<long> EnumerateIds(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "mutes/users/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<long> Ids(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "mutes/users/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "mutes/users/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateIds<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "mutes/users/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> IdsAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "mutes/users/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<User>, T>(MethodType.Get, "mutes/users/list", parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<User> EnumerateList(EnumerateMode mode, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<User>.Enumerate(this.Tokens, "mutes/users/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<User> List(long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "mutes/users/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "mutes/users/list", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<User> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<User>.Enumerate(this.Tokens, "mutes/users/list", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<User>, T>(MethodType.Get, "mutes/users/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of user objects the authenticating user has muted.</para>
        /// </summary>
        /// <param name="cursor">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<User>> ListAsync(long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<User>>(MethodType.Get, "mutes/users/list", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "mutes/users/create", parameters);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The muted user.</returns>
        public UserResponse Create(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "mutes/users/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the muted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The muted user.</returns>
        public Task<UserResponse> CreateAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The unmuted user.</returns>
        public UserResponse Destroy(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-mutes the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the unmuted user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.</para>
        /// <para>Actions taken in this method are asynchronous and changes will be eventually consistent.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The unmuted user.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "mutes/users/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST saved_searches.
    /// </summary>
    public partial class SavedSearches : ApiProviderBase
    {
        internal SavedSearches (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<SearchQuery, T>(MethodType.Get, "saved_searches/list", parameters);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// </summary>
        /// <returns>The saved searches.</returns>
        public ListedResponse<SearchQuery> List()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<SearchQuery>(MethodType.Get, "saved_searches/list", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<SearchQuery, T>(MethodType.Get, "saved_searches/list", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the authenticated user’s saved search queries.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved searches.</returns>
        public Task<ListedResponse<SearchQuery>> ListAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<SearchQuery>(MethodType.Get, "saved_searches/list", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Show(long id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Retrieve the information for the saved search represented by the given id.</para>
        /// <para>The authenticating user must be the owner of saved search ID being requested.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> ShowAsync(long id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Get, "saved_searches/show/{id}", "id", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<SearchQueryResponse, T>(MethodType.Post, "saved_searches/create", parameters);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Create(string query)
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            else parameters.Add("query", query);
            return this.Tokens.AccessApi<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> query (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchQueryResponse, T>(MethodType.Post, "saved_searches/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Create a new saved search for the authenticated user.</para>
        /// <para>A user may only have 25 saved searches.</para>
        /// </summary>
        /// <param name="query">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> CreateAsync(string query, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(query == null) throw new ArgumentNullException("query");
            else parameters.Add("query", query);
            return this.Tokens.AccessApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <returns>The saved search.</returns>
        public SearchQueryResponse Destroy(long id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApi<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Destroys a saved search for the authenticating user.</para>
        /// <para>The authenticating user must be the owner of saved search id being destroyed.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The saved search.</returns>
        public Task<SearchQueryResponse> DestroyAsync(long id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            return this.Tokens.AccessParameterReservedApiAsync<SearchQueryResponse>(MethodType.Post, "saved_searches/destroy/{id}", "id", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET search.
    /// </summary>
    public partial class Search : ApiProviderBase
    {
        internal Search (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets<T>(T parameters)
        {
            return this.Tokens.AccessApi<SearchResult, T>(MethodType.Get, "search/tweets", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="geocode">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="locale">optional.</param>
        /// <param name="result_type">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="until">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public SearchResult Tweets(string q, string geocode = null, string lang = null, string locale = null, string result_type = null, int? count = null, string until = null, long? since_id = null, long? max_id = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            else parameters.Add("q", q);
            if(geocode != null) parameters.Add("geocode", geocode);
            if(lang != null) parameters.Add("lang", lang);
            if(locale != null) parameters.Add("locale", locale);
            if(result_type != null) parameters.Add("result_type", result_type);
            if(count != null) parameters.Add("count", count);
            if(until != null) parameters.Add("until", until);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<SearchResult>(MethodType.Get, "search/tweets", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>string</c> geocode (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> locale (optional)</para>
        /// <para>- <c>string</c> result_type (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>string</c> until (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<SearchResult, T>(MethodType.Get, "search/tweets", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of relevant Tweets matching a specified query.</para>
        /// <para>Please note that Twitter’s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="geocode">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="locale">optional.</param>
        /// <param name="result_type">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="until">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<SearchResult> TweetsAsync(string q, string geocode = null, string lang = null, string locale = null, string result_type = null, int? count = null, string until = null, long? since_id = null, long? max_id = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            else parameters.Add("q", q);
            if(geocode != null) parameters.Add("geocode", geocode);
            if(lang != null) parameters.Add("lang", lang);
            if(locale != null) parameters.Add("locale", locale);
            if(result_type != null) parameters.Add("result_type", result_type);
            if(count != null) parameters.Add("count", count);
            if(until != null) parameters.Add("until", until);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<SearchResult>(MethodType.Get, "search/tweets", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST statuses.
    /// </summary>
    public partial class Statuses : ApiProviderBase
    {
        internal Statuses (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "statuses/mentions_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> MentionsTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? contributor_details = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/mentions_timeline", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the 20 most recent mentions (tweets containing a users's &#64;screen_name) for the authenticating user.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.</para>
        /// <para>This method can only return up to 800 tweets.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> MentionsTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? contributor_details = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/mentions_timeline", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(long user_id, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> UserTimeline(string screen_name, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_rts (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(long user_id, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets posted by the user indicated by the screen_name or user_id parameters.</para>
        /// <para>User timelines belonging to protected users may only be requested when the authenticated user either "owns" the timeline or is an approved follower of the owner.</para>
        /// <para>The timeline returned is the equivalent of the one seen when you view a user's profile on twitter.com.</para>
        /// <para>This method can only return up to 3,200 of a user's most recent Tweets.</para>
        /// <para>Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is set to false when requesting this resource.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_rts">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> UserTimelineAsync(string screen_name, int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_rts = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_rts != null) parameters.Add("include_rts", include_rts);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/user_timeline", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "statuses/home_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> HomeTimeline(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/home_timeline", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> exclude_replies (optional)</para>
        /// <para>- <c>bool</c> contributor_details (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow.</para>
        /// <para>The home timeline is central to how most users interact with the Twitter service.</para>
        /// <para>Up to 800 Tweets are obtainable on the home timeline.</para>
        /// <para>It is more volatile for users that follow many users or follow users who tweet frequently.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="exclude_replies">optional.</param>
        /// <param name="contributor_details">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> HomeTimelineAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? exclude_replies = null, bool? contributor_details = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(exclude_replies != null) parameters.Add("exclude_replies", exclude_replies);
            if(contributor_details != null) parameters.Add("contributor_details", contributor_details);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/home_timeline", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "statuses/retweets_of_me", parameters);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> RetweetsOfMe(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? include_entities = null, bool? include_user_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/retweets_of_me", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>long</c> since_id (optional)</para>
        /// <para>- <c>long</c> max_id (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> include_user_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the most recent tweets authored by the authenticating user that have recently been retweeted by others.</para>
        /// <para>This timeline is a subset of the user's GET statuses/user_timeline.</para>
        /// </summary>
        /// <param name="count">optional.</param>
        /// <param name="since_id">optional.</param>
        /// <param name="max_id">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="include_user_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsOfMeAsync(int? count = null, long? since_id = null, long? max_id = null, bool? trim_user = null, bool? include_entities = null, bool? include_user_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(count != null) parameters.Add("count", count);
            if(since_id != null) parameters.Add("since_id", since_id);
            if(max_id != null) parameters.Add("max_id", max_id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(include_user_entities != null) parameters.Add("include_user_entities", include_user_entities);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/retweets_of_me", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed<T>(T parameters)
        {
            return this.Tokens.AccessApi<Embed, T>(MethodType.Get, "statuses/oembed", parameters);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// </summary>
        /// <param name="id">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(long id, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// </summary>
        /// <param name="url">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <returns>The HTML code and more.</returns>
        public Embed Oembed(string url, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null)
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            else parameters.Add("url", url);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            return this.Tokens.AccessApi<Embed>(MethodType.Get, "statuses/oembed", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (any one is required)</para>
        /// <para>- <c>string</c> url (any one is required)</para>
        /// <para>- <c>int</c> maxwidth (optional)</para>
        /// <para>- <c>bool</c> hide_media (optional)</para>
        /// <para>- <c>bool</c> hide_thread (optional)</para>
        /// <para>- <c>bool</c> omit_script (optional)</para>
        /// <para>- <c>string</c> align (optional)</para>
        /// <para>- <c>string</c> related (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// <para>- <c>string</c> widget_type (optional)</para>
        /// <para>- <c>bool</c> hide_tweet (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Embed, T>(MethodType.Get, "statuses/oembed", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// </summary>
        /// <param name="id">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(long id, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns information allowing the creation of an embedded representation of a Tweet on third party sites.</para>
        /// <para>While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter's Display Requirements.</para>
        /// <para>Do not rely on any class or id parameters to stay constant in the returned markup.</para>
        /// </summary>
        /// <param name="url">any one is required.</param>
        /// <param name="maxwidth">optional.</param>
        /// <param name="hide_media">optional.</param>
        /// <param name="hide_thread">optional.</param>
        /// <param name="omit_script">optional.</param>
        /// <param name="align">optional.</param>
        /// <param name="related">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="widget_type">optional.</param>
        /// <param name="hide_tweet">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The HTML code and more.</returns>
        public Task<Embed> OembedAsync(string url, int? maxwidth = null, bool? hide_media = null, bool? hide_thread = null, bool? omit_script = null, string align = null, string related = null, string lang = null, string widget_type = null, bool? hide_tweet = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(url == null) throw new ArgumentNullException("url");
            else parameters.Add("url", url);
            if(maxwidth != null) parameters.Add("maxwidth", maxwidth);
            if(hide_media != null) parameters.Add("hide_media", hide_media);
            if(hide_thread != null) parameters.Add("hide_thread", hide_thread);
            if(omit_script != null) parameters.Add("omit_script", omit_script);
            if(align != null) parameters.Add("align", align);
            if(related != null) parameters.Add("related", related);
            if(lang != null) parameters.Add("lang", lang);
            if(widget_type != null) parameters.Add("widget_type", widget_type);
            if(hide_tweet != null) parameters.Add("hide_tweet", hide_tweet);
            return this.Tokens.AccessApiAsync<Embed>(MethodType.Get, "statuses/oembed", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_my_retweet">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The status.</returns>
        public StatusResponse Show(long id, bool? trim_user = null, bool? include_my_retweet = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_my_retweet != null) parameters.Add("include_my_retweet", include_my_retweet);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_my_retweet (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Returns a single Tweet, specified by the id parameter.</para>
        /// <para>The Tweet's author will also be embedded within the tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_my_retweet">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The status.</returns>
        public Task<StatusResponse> ShowAsync(long id, bool? trim_user = null, bool? include_my_retweet = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_my_retweet != null) parameters.Add("include_my_retweet", include_my_retweet);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Get, "statuses/show/{id}", "id", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Retweets(long id, int? count = null, bool? trim_user = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApiArray<Status>(MethodType.Get, "statuses/retweets/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Returns up to 100 of the first retweets of a given tweet.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="count">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> RetweetsAsync(long id, int? count = null, bool? trim_user = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(count != null) parameters.Add("count", count);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApiArrayAsync<Status>(MethodType.Get, "statuses/retweets/{id}", "id", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Status, T>(MethodType.Get, "statuses/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The statuses.</returns>
        public ListedResponse<Status> Lookup(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            else parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<Status>(MethodType.Get, "statuses/lookup", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Status, T>(MethodType.Get, "statuses/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated tweet objects for up to 100 tweets per request, as specified by comma-separated values passed to the id parameter.</para>
        /// <para>This method is especially useful to get the details (hydrate) a collection of Tweet IDs.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The statuses.</returns>
        public Task<ListedResponse<Status>> LookupAsync(IEnumerable<long> id, bool? trim_user = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(id == null) throw new ArgumentNullException("id");
            else parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<Status>(MethodType.Get, "statuses/lookup", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "statuses/retweeters/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, long id, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "statuses/retweeters/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>The IDs.</returns>
        public Cursored<long> RetweetersIds(long id, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "statuses/retweeters/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "statuses/retweeters/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The IDs.</returns>
        public IEnumerable<long> EnumerateRetweetersIds<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "statuses/retweeters/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of up to 100 user IDs belonging to users who have retweeted the tweet specified by the id parameter.</para>
        /// <para>This method offers similar data to GET statuses/retweets/:id and replaces API v1's GET statuses/:id/retweeted_by/ids method.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The IDs.</returns>
        public Task<Cursored<long>> RetweetersIdsAsync(long id, long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "statuses/retweeters/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update<T>(T parameters)
        {
            return this.Tokens.AccessApi<StatusResponse, T>(MethodType.Post, "statuses/update", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="media_ids">optional.</param>
        /// <returns>The updated status.</returns>
        public StatusResponse Update(string status, long? in_reply_to_status_id = null, bool? possibly_sensitive = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, bool? trim_user = null, IEnumerable<long> media_ids = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(media_ids != null) parameters.Add("media_ids", media_ids);
            return this.Tokens.AccessApi<StatusResponse>(MethodType.Post, "statuses/update", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> media_ids (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<StatusResponse, T>(MethodType.Post, "statuses/update", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status, also known as Tweeting.</para>
        /// <para>For each update attempt, the update text is compared with the authenticating user’s recent Tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row.</para>
        /// <para>While not rate limited by the API a user is limited in the number of Tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="media_ids">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateAsync(string status, long? in_reply_to_status_id = null, bool? possibly_sensitive = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, bool? trim_user = null, IEnumerable<long> media_ids = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            if(media_ids != null) parameters.Add("media_ids", media_ids);
            return this.Tokens.AccessApiAsync<StatusResponse>(MethodType.Post, "statuses/update", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateWithMediaImpl(InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(IDictionary<string, object> parameters)
        {
            return this.UpdateWithMediaImpl(parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia<T>(T parameters)
        {
            return this.UpdateWithMediaImpl(InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, Stream media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, IEnumerable<byte> media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <returns>The updated status.</returns>
        [Obsolete("Use Media.Upload and Statuses.Update.")]
        public StatusResponse UpdateWithMedia(string status, FileInfo media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null)
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaImpl(parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.UpdateWithMediaAsyncImpl(InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> status (required)</para>
        /// <para>- <c>Stream</c> media (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> media (any one is required)</para>
        /// <para>- <c>FileInfo</c> media (any one is required)</para>
        /// <para>- <c>bool</c> possibly_sensitive (optional)</para>
        /// <para>- <c>long</c> in_reply_to_status_id (optional)</para>
        /// <para>- <c>double</c> lat (optional)</para>
        /// <para>- <c>double</c> long (optional)</para>
        /// <para>- <c>string</c> place_id (optional)</para>
        /// <para>- <c>bool</c> display_coordinates (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.UpdateWithMediaAsyncImpl(InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync(string status, Stream media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync(string status, IEnumerable<byte> media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user’s current status and attaches media for upload. In other words, it creates a Tweet with a picture attached.</para>
        /// <para>The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error.</para>
        /// </summary>
        /// <param name="status">required.</param>
        /// <param name="media">any one is required.</param>
        /// <param name="possibly_sensitive">optional.</param>
        /// <param name="in_reply_to_status_id">optional.</param>
        /// <param name="lat">optional.</param>
        /// <param name="long">optional.</param>
        /// <param name="place_id">optional.</param>
        /// <param name="display_coordinates">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The updated status.</returns>
        public Task<StatusResponse> UpdateWithMediaAsync(string status, FileInfo media, bool? possibly_sensitive = null, long? in_reply_to_status_id = null, double? lat = null, double? @long = null, string place_id = null, bool? display_coordinates = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(status == null) throw new ArgumentNullException("status");
            else parameters.Add("status", status);
            if(media == null) throw new ArgumentNullException("media");
            else parameters.Add("media", media);
            if(possibly_sensitive != null) parameters.Add("possibly_sensitive", possibly_sensitive);
            if(in_reply_to_status_id != null) parameters.Add("in_reply_to_status_id", in_reply_to_status_id);
            if(lat != null) parameters.Add("lat", lat);
            if(@long != null) parameters.Add("long", @long);
            if(place_id != null) parameters.Add("place_id", place_id);
            if(display_coordinates != null) parameters.Add("display_coordinates", display_coordinates);
            return this.UpdateWithMediaAsyncImpl(parameters, cancellationToken);
        }
        #endif

        #endif

        #if !(PCL || WIN_RT || WP)
        private StatusResponse UpdateWithMediaImpl(IEnumerable<KeyValuePair<string, object>> parameters)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            var list = parameters.ToList();
            list.Where(kvp => kvp.Key == "media").ToArray().ForEach(kvp =>
            {
                list.Remove(kvp);
                list.Add(new KeyValuePair<string, object>("media[]", kvp.Value));
            });
            return this.Tokens.AccessApiImpl<StatusResponse>(MethodType.Post, "statuses/update_with_media", list, "");
        }
        #endif
        #if !NET35
        private Task<StatusResponse> UpdateWithMediaAsyncImpl(IEnumerable<KeyValuePair<string, object>> parameters, CancellationToken cancellationToken)
        {
            if(parameters == null) throw new ArgumentNullException("parameters");
            var list = parameters.ToList();
            list.Where(kvp => kvp.Key == "media").ToArray().ForEach(kvp =>
            {
                list.Remove(kvp);
                list.Add(new KeyValuePair<string, object>("media[]", kvp.Value));
            });
            return this.Tokens.AccessApiAsyncImpl<StatusResponse>(MethodType.Post, "statuses/update_with_media", list, cancellationToken, "");
        }
        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <returns>The destroyed status.</returns>
        public StatusResponse Destroy(long id, bool? trim_user = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Destroys the status specified by the required ID parameter.</para>
        /// <para>The authenticating user must be the author of the specified status.</para>
        /// <para>Returns the destroyed status if successful.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The destroyed status.</returns>
        public Task<StatusResponse> DestroyAsync(long id, bool? trim_user = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/destroy/{id}", "id", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", parameters);
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <returns>The retweeted status.</returns>
        public StatusResponse Retweet(long id, bool? trim_user = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApi<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>bool</c> trim_user (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Retweets a tweet. Returns the original tweet with retweet details embedded.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="trim_user">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The retweeted status.</returns>
        public Task<StatusResponse> RetweetAsync(long id, bool? trim_user = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(trim_user != null) parameters.Add("trim_user", trim_user);
            return this.Tokens.AccessParameterReservedApiAsync<StatusResponse>(MethodType.Post, "statuses/retweet/{id}", "id", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET trends.
    /// </summary>
    public partial class Trends : ApiProviderBase
    {
        internal Trends (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters: Nothing.</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation, T>(MethodType.Get, "trends/available", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// </summary>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Available()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/available", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation, T>(MethodType.Get, "trends/available", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for.</para>
        /// <para>The response is an array of "locations" that encode the location's id and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> AvailableAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/available", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<TrendLocation, T>(MethodType.Get, "trends/closest", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <returns>The locations.</returns>
        public ListedResponse<TrendLocation> Closest(double lat, double @long)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            return this.Tokens.AccessApiArray<TrendLocation>(MethodType.Get, "trends/closest", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>double</c> lat (required)</para>
        /// <para>- <c>double</c> long (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendLocation, T>(MethodType.Get, "trends/closest", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the locations that Twitter has trending topic information for, closest to a specified location.</para>
        /// <para>The response is an array of "locations" that encode the location's ID and some other human-readable information such as a canonical name and country the location belongs in.</para>
        /// <para>A id is a Yahoo! Where On Earth ID.</para>
        /// <para>See also: http://developer.yahoo.com/geo/geoplanet/</para>
        /// </summary>
        /// <param name="lat">required.</param>
        /// <param name="long">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The locations.</returns>
        public Task<ListedResponse<TrendLocation>> ClosestAsync(double lat, double @long, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("lat", lat);
            parameters.Add("long", @long);
            return this.Tokens.AccessApiArrayAsync<TrendLocation>(MethodType.Get, "trends/closest", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<TrendsResult, T>(MethodType.Get, "trends/place", parameters);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="exclude">optional.</param>
        /// <returns>The queries.</returns>
        public ListedResponse<TrendsResult> Place(long id, string exclude = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(exclude != null) parameters.Add("exclude", exclude);
            return this.Tokens.AccessApiArray<TrendsResult>(MethodType.Get, "trends/place", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> id (required)</para>
        /// <para>- <c>string</c> exclude (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<TrendsResult, T>(MethodType.Get, "trends/place", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the top 10 trending topics for a specific id, if trending information is available for it.</para>
        /// <para>The response is an array of "trend" objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.</para>
        /// <para>This information is cached for 5 minutes.</para>
        /// <para>Requesting more frequently than that will not return any more data, and will count against your rate limit usage.</para>
        /// </summary>
        /// <param name="id">required.</param>
        /// <param name="exclude">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The queries.</returns>
        public Task<ListedResponse<TrendsResult>> PlaceAsync(long id, string exclude = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("id", id);
            if(exclude != null) parameters.Add("exclude", exclude);
            return this.Tokens.AccessApiArrayAsync<TrendsResult>(MethodType.Get, "trends/place", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST users.
    /// </summary>
    public partial class Users : ApiProviderBase
    {
        internal Users (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("user_id");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner<T>(T parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes, T>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes, T>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(string q, int? page = null, int? count = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            else parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(string q, int? page = null, int? count = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("q");
            else parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long user_id, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string screen_name, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long user_id, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string screen_name, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Category, T>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category, T>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(string slug, string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(string slug, string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(string slug)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(string slug, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("slug");
            else parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("screen_name");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        #endif

    }

}
