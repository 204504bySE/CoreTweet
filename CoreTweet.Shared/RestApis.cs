// This file was automatically generated by CoreTweet.
// Do not modify this file directly.

// The MIT License (MIT)
//
// CoreTweet - A .NET Twitter Library supporting Twitter API 1.1
// Copyright (c) 2013-2015 CoreTweet Development Team
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using CoreTweet.Core;
#if !NET35
using System.Threading;
using System.Threading.Tasks;
#endif

namespace CoreTweet.Rest
{

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST account.
    /// </summary>
    public partial class Account : ApiProviderBase
    {
        internal Account (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse VerifyCredencials(bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a representation of the requesting user if authentication was successful.</para>
        /// <para>Use this method to test if supplied user credentials are valid.</para>
        /// </summary>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> VerifyCredencialsAsync(bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "account/verify_credencials", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings<T>(T parameters)
        {
            return this.Tokens.AccessApi<Setting, T>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <returns>The settings of the user.</returns>
        public Setting Settings(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApi<Setting>(MethodType.Post, "account/settings", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>int</c> trend_location_woeid (optional)</para>
        /// <para>- <c>bool</c> sleep_time_enabled (optional)</para>
        /// <para>- <c>int</c> start_sleep_time (optional)</para>
        /// <para>- <c>int</c> end_sleep_time (optional)</para>
        /// <para>- <c>string</c> time_zone (optional)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Setting, T>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns settings (including current trend, geo and sleep time information) for the authenticating user or updates the authenticating user's settings.</para>
        /// </summary>
        /// <param name="trend_location_woeid">optional.</param>
        /// <param name="sleep_time_enabled">optional.</param>
        /// <param name="start_sleep_time">optional.</param>
        /// <param name="end_sleep_time">optional.</param>
        /// <param name="time_zone">optional.</param>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The settings of the user.</returns>
        public Task<Setting> SettingsAsync(int? trend_location_woeid = null, bool? sleep_time_enabled = null, int? start_sleep_time = null, int? end_sleep_time = null, string time_zone = null, string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(trend_location_woeid != null) parameters.Add("trend_location_woeid", trend_location_woeid);
            if(sleep_time_enabled != null) parameters.Add("sleep_time_enabled", sleep_time_enabled);
            if(start_sleep_time != null) parameters.Add("start_sleep_time", start_sleep_time);
            if(end_sleep_time != null) parameters.Add("end_sleep_time", end_sleep_time);
            if(time_zone != null) parameters.Add("time_zone", time_zone);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiAsync<Setting>(MethodType.Post, "account/settings", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// </summary>
        /// <param name="device">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public void UpdateDeliveryService(string device, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(device == null) throw new ArgumentNullException("A required argument 'device' must not be null");
            else parameters.Add("device", device);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            this.Tokens.AccessApiNoResponse("account/update_delivery_service", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> device (required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets which device Twitter delivers updates to for the authenticating user.</para>
        /// <para>Sending none as the device parameter will disable SMS updates.</para>
        /// </summary>
        /// <param name="device">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The task object representing the asynchronous operation will be returned in async methods. In other methods, nothing.</returns>
        public Task UpdateDeliveryServiceAsync(string device, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(device == null) throw new ArgumentNullException("A required argument 'device' must not be null");
            else parameters.Add("device", device);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiNoResponseAsync("account/update_delivery_service", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfile(string name = null, string url = null, string location = null, string description = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> name (optional)</para>
        /// <para>- <c>string</c> url (optional)</para>
        /// <para>- <c>string</c> location (optional)</para>
        /// <para>- <c>string</c> description (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets values that users are able to set under the "Account" tab of their settings page.</para>
        /// <para>Only the parameters specified will be updated.</para>
        /// </summary>
        /// <param name="name">optional.</param>
        /// <param name="url">optional.</param>
        /// <param name="location">optional.</param>
        /// <param name="description">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileAsync(string name = null, string url = null, string location = null, string description = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(name != null) parameters.Add("name", name);
            if(url != null) parameters.Add("url", url);
            if(location != null) parameters.Add("location", location);
            if(description != null) parameters.Add("description", description);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImage(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> tile (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// <para>- <c>bool</c> use (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(Stream image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(IEnumerable<byte> image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageAsync(FileInfo image, bool? tile = null, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }
        #endif

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImageTile(bool tile, bool? include_entities = null, bool? skip_status = null, bool? use = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="tile">required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="use">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageTileAsync(bool tile, bool? include_entities = null, bool? skip_status = null, bool? use = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            if(use != null) parameters.Add("use", use);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="use">required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileBackgroundImageUse(bool use, bool? tile = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("use", use);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile background image.</para>
        /// <para>This method can also be used to enable or disable the profile background image.</para>
        /// <para>Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.</para>
        /// </summary>
        /// <param name="use">required.</param>
        /// <param name="tile">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileBackgroundImageUseAsync(bool use, bool? tile = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("use", use);
            if(tile != null) parameters.Add("tile", tile);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_background_image", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void UpdateProfileBanner<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <returns></returns>
        public void UpdateProfileBanner(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            this.Tokens.AccessApiNoResponse("account/update_profile_banner", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>string</c> width (optional)</para>
        /// <para>- <c>string</c> height (optional)</para>
        /// <para>- <c>string</c> offset_left (optional)</para>
        /// <para>- <c>string</c> offset_top (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(Stream image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(IEnumerable<byte> image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Uploads a profile banner on behalf of the authenticating user.</para>
        /// <para>For best results, upload an &lt;3MB image that is exactly 1500px by 500px.</para>
        /// <para>Images will be resized for a number of display options. Users with an uploaded profile banner will have a profile_banner_url node in their Users objects.</para>
        /// <para>More information about sizing variations can be found in https://dev.twitter.com/docs/user-profile-images-and-banners.</para>
        /// <para>Profile banner images are processed asynchronously.</para>
        /// <para>The profile_banner_url and its variant sizes will not necessary be available directly after upload.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="width">optional.</param>
        /// <param name="height">optional.</param>
        /// <param name="offset_left">optional.</param>
        /// <param name="offset_top">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task UpdateProfileBannerAsync(FileInfo image, string width = null, string height = null, string offset_left = null, string offset_top = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(width != null) parameters.Add("width", width);
            if(height != null) parameters.Add("height", height);
            if(offset_left != null) parameters.Add("offset_left", offset_left);
            if(offset_top != null) parameters.Add("offset_top", offset_top);
            return this.Tokens.AccessApiNoResponseAsync("account/update_profile_banner", parameters, cancellationToken);
        }
        #endif

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner(IDictionary<string, object> parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public void RemoveProfileBanner<T>(T parameters)
        {
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <returns></returns>
        public void RemoveProfileBanner()
        {
            var parameters = new Dictionary<string, object>();
            this.Tokens.AccessApiNoResponse("account/remove_profile_banner", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Removes the uploaded profile banner for the authenticating user.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task RemoveProfileBannerAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiNoResponseAsync("account/remove_profile_banner", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// </summary>
        /// <param name="profile_background_color">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="profile_sidebar_border_color">optional.</param>
        /// <param name="profile_sidebar_fill_color">optional.</param>
        /// <param name="profile_text_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileColors(string profile_background_color = null, string profile_link_color = null, string profile_sidebar_border_color = null, string profile_sidebar_fill_color = null, string profile_text_color = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(profile_background_color != null) parameters.Add("profile_background_color", profile_background_color);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(profile_sidebar_border_color != null) parameters.Add("profile_sidebar_border_color", profile_sidebar_border_color);
            if(profile_sidebar_fill_color != null) parameters.Add("profile_sidebar_fill_color", profile_sidebar_fill_color);
            if(profile_text_color != null) parameters.Add("profile_text_color", profile_text_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> profile_background_color (optional)</para>
        /// <para>- <c>string</c> profile_link_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_border_color (optional)</para>
        /// <para>- <c>string</c> profile_sidebar_fill_color (optional)</para>
        /// <para>- <c>string</c> profile_text_color (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Sets one or more hex values that control the color scheme of the authenticating user's profile page on twitter.com.</para>
        /// <para>Each parameter's value must be a valid hexidecimal value, and may be either three or six characters (ex: &#35;fff or &#35;ffffff).</para>
        /// </summary>
        /// <param name="profile_background_color">optional.</param>
        /// <param name="profile_link_color">optional.</param>
        /// <param name="profile_sidebar_border_color">optional.</param>
        /// <param name="profile_sidebar_fill_color">optional.</param>
        /// <param name="profile_text_color">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileColorsAsync(string profile_background_color = null, string profile_link_color = null, string profile_sidebar_border_color = null, string profile_sidebar_fill_color = null, string profile_text_color = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(profile_background_color != null) parameters.Add("profile_background_color", profile_background_color);
            if(profile_link_color != null) parameters.Add("profile_link_color", profile_link_color);
            if(profile_sidebar_border_color != null) parameters.Add("profile_sidebar_border_color", profile_sidebar_border_color);
            if(profile_sidebar_fill_color != null) parameters.Add("profile_sidebar_fill_color", profile_sidebar_fill_color);
            if(profile_text_color != null) parameters.Add("profile_text_color", profile_text_color);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_colors", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(Stream image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse UpdateProfileImage(FileInfo image, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }
        #endif

        #endif
        #if !NET35

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>Stream</c> image (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;byte&gt;</c> image (any one is required)</para>
        /// <para>- <c>FileInfo</c> image (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(Stream image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(IEnumerable<byte> image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }

        #if !(PCL || WIN_RT)
        /// <summary>
        /// <para>Updates the authenticating user's profile image.</para>
        /// <para>Note that this method expects raw multipart data, not a URL to an image.</para>
        /// <para>This method asynchronously processes the uploaded file before updating the user's profile image URL.</para>
        /// <para>You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.</para>
        /// </summary>
        /// <param name="image">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> UpdateProfileImageAsync(FileInfo image, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(image == null) throw new ArgumentNullException("A required argument 'image' must not be null");
            else parameters.Add("image", image);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "account/update_profile_image", parameters, cancellationToken);
        }
        #endif

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET application.
    /// </summary>
    public partial class Application : ApiProviderBase
    {
        internal Application (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus<T>(T parameters)
        {
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus()
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// <para>Available parameters:</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>, T>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(string resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("A required argument 'resources' must not be null");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <returns></returns>
        public DictionaryResponse<string, Dictionary<string, RateLimit>> RateLimitStatus(IEnumerable<string> resources)
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("A required argument 'resources' must not be null");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionary<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, "resources");
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(string resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("A required argument 'resources' must not be null");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        /// <summary>
        /// <para>Returns the current rate limits for methods belonging to the specified resource families.</para>
        /// </summary>
        /// <param name="resources">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        public Task<DictionaryResponse<string, Dictionary<string, RateLimit>>> RateLimitStatusAsync(IEnumerable<string> resources, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(resources == null) throw new ArgumentNullException("A required argument 'resources' must not be null");
            else parameters.Add("resources", resources);
            return this.Tokens.AccessApiDictionaryAsync<string, Dictionary<string, RateLimit>>(MethodType.Get, "application/rate_limit_status", parameters, cancellationToken, "resources");
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST blocks.
    /// </summary>
    public partial class Blocks : ApiProviderBase
    {
        internal Blocks (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> IDs(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> IDs(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> IDs<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        IEnumerable<long> EnumerateIDs(EnumerateMode mode, long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <returns>IDs.</returns>
        public Cursored<long> IDs(long? cursor = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIDs(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIDs(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>IDs.</returns>
        public IEnumerable<long> EnumerateIDs<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IDsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IDsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IDsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns an array of numeric user ids the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>IDs.</returns>
        public Task<Cursored<long>> IDsAsync(long? cursor = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List<T>(T parameters)
        {
            return this.Tokens.AccessApi<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        IEnumerable<long> EnumerateList(EnumerateMode mode, long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public Cursored<long> List(long? cursor = null, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList(EnumerateMode mode, params Expression<Func<string, object>>[] parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList(EnumerateMode mode, IDictionary<string, object> parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="mode">Specify whether enumerating goes to the next page or the previous.</param>
        /// <returns>The users.</returns>
        public IEnumerable<long> EnumerateList<T>(EnumerateMode mode, T parameters)
        {
            return Cursored<long>.Enumerate(this.Tokens, "blocks/ids", mode, parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> cursor (semi-optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<Cursored<long>, T>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of user objects that the authenticating user is blocking.</para>
        /// </summary>
        /// <param name="cursor">semi-optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<Cursored<long>> ListAsync(long? cursor = null, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(cursor != null) parameters.Add("cursor", cursor);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<Cursored<long>>(MethodType.Get, "blocks/ids", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Create(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Blocks the specified user from following the authenticating user.</para>
        /// <para>In addition the blocked user will not show in the authenticating users mentions or timeline.</para>
        /// <para>If a follow or friend relationship exists it is destroyed.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> CreateAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/create", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The user object.</returns>
        public UserResponse Destroy(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Un-blocks the user specified in the ID parameter for the authenticating user.</para>
        /// <para>Returns the un-blocked user in the requested format when successful.</para>
        /// <para>If relationships existed before the block was instated, they will not be restored.</para>
        /// <para>Note: Either screen_name or user_id must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user object.</returns>
        public Task<UserResponse> DestroyAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "blocks/destroy", parameters, cancellationToken);
        }

        #endif

    }

    /// <summary>
    /// Provides a set of methods for the wrapper of GET/POST users.
    /// </summary>
    public partial class Users : ApiProviderBase
    {
        internal Users (TokensBase e) : base(e) { }

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributees(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributees", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users that the specified user can "contribute" to.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributeesAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributees", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(long user_id, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Contributors(string screen_name, bool? include_entities = null, bool? skip_status = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/contributors", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// <para>- <c>bool</c> skip_status (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(long user_id, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a collection of users who can contribute to the specified account.</para>
        /// <para>Note: A user_id or screen_name is required.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="skip_status">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> ContributorsAsync(string screen_name, bool? include_entities = null, bool? skip_status = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            if(skip_status != null) parameters.Add("skip_status", skip_status);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/contributors", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<long> user_id)
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("A required argument 'user_id' must not be null");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Lookup(IEnumerable<string> screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/lookup", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>IEnumerable&lt;long&gt;</c> user_id (any one is required)</para>
        /// <para>- <c>IEnumerable&lt;string&gt;</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<long> user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(user_id == null) throw new ArgumentNullException("A required argument 'user_id' must not be null");
            else parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.</para>
        /// <para>This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.</para>
        /// <para>GET users/show is used to retrieve a single user object.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> LookupAsync(IEnumerable<string> screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/lookup", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner<T>(T parameters)
        {
            return this.Tokens.AccessApi<ProfileBannerSizes, T>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The sizes.</returns>
        public ProfileBannerSizes ProfileBanner(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<ProfileBannerSizes, T>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns the size of the specified user's profile banner.</para>
        /// <para>If the user has not uploaded a profile banner, a HTTP 404 will be served instead.</para>
        /// <para>This method can be used instead of string manipulation on the profile_banner_url returned in user objects as described in User Profile Images and Banners.</para>
        /// <para>Note: Always specify either an user_id or screen_name when requesting this method.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The sizes.</returns>
        public Task<ProfileBannerSizes> ProfileBannerAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<ProfileBannerSizes>(MethodType.Get, "users/profile_banner", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<User, T>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> Search(string q, int? page = null, int? count = null, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("A required argument 'q' must not be null");
            else parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArray<User>(MethodType.Get, "users/search", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> q (required)</para>
        /// <para>- <c>int</c> page (optional)</para>
        /// <para>- <c>int</c> count (optional)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<User, T>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Provides a simple, relevance-based search interface to public user accounts on Twitter.</para>
        /// <para>Try querying by topical interest, full name, company name, location, or other criteria.</para>
        /// <para>Exact match searches are not supported.</para>
        /// </summary>
        /// <param name="q">required.</param>
        /// <param name="page">optional.</param>
        /// <param name="count">optional.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SearchAsync(string q, int? page = null, int? count = null, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(q == null) throw new ArgumentNullException("A required argument 'q' must not be null");
            else parameters.Add("q", q);
            if(page != null) parameters.Add("page", page);
            if(count != null) parameters.Add("count", count);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiArrayAsync<User>(MethodType.Get, "users/search", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse Show<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(long user_id, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <returns>The user.</returns>
        public UserResponse Show(string screen_name, bool? include_entities = null)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>bool</c> include_entities (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(long user_id, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Returns a variety of information about the user specified by the required user_id or screen_name parameter.</para>
        /// <para>The author's most recent Tweet will be returned inline when possible.</para>
        /// <para>GET users/lookup is used to retrieve a bulk collection of user objects.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="include_entities">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ShowAsync(string screen_name, bool? include_entities = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            if(include_entities != null) parameters.Add("include_entities", include_entities);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Get, "users/show", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions<T>(T parameters)
        {
            return this.Tokens.AccessApiArray<Category, T>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <returns>The categories.</returns>
        public ListedResponse<Category> Suggestions(string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArray<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiArrayAsync<Category, T>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access to Twitter's suggested user list.</para>
        /// <para>This returns the list of suggested user categories.</para>
        /// <para>The category can be used in GET users/suggestions/:slug to get the users in that category.</para>
        /// </summary>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The categories.</returns>
        public Task<ListedResponse<Category>> SuggestionsAsync(string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessApiArrayAsync<Category>(MethodType.Get, "users/suggestions", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <returns>The category.</returns>
        public CategoryResponse Suggestion(string slug, string lang = null)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("A required argument 'slug' must not be null");
            else parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApi<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// <para>- <c>string</c> lang (optional)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list.</para>
        /// <para>It is recommended that applications cache this data for no more than one hour.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="lang">optional.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The category.</returns>
        public Task<CategoryResponse> SuggestionAsync(string slug, string lang = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("A required argument 'slug' must not be null");
            else parameters.Add("slug", slug);
            if(lang != null) parameters.Add("lang", lang);
            return this.Tokens.AccessParameterReservedApiAsync<CategoryResponse>(MethodType.Get, "users/suggestions/{slug}", "slug", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ExpressionsToDictionary(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers<T>(T parameters)
        {
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ResolveObject(parameters));
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <returns>The users.</returns>
        public ListedResponse<User> SuggestedMembers(string slug)
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("A required argument 'slug' must not be null");
            else parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArray<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ExpressionsToDictionary(parameters), CancellationToken.None);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> slug (required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", InternalUtils.ResolveObject(parameters), cancellationToken);
        }

        /// <summary>
        /// <para>Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.</para>
        /// </summary>
        /// <param name="slug">required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The users.</returns>
        public Task<ListedResponse<User>> SuggestedMembersAsync(string slug, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(slug == null) throw new ArgumentNullException("A required argument 'slug' must not be null");
            else parameters.Add("slug", slug);
            return this.Tokens.AccessParameterReservedApiArrayAsync<User>(MethodType.Get, "users/suggestions/{slug}/members", "slug", parameters, cancellationToken);
        }

        #endif

        #if !(PCL || WIN_RT || WP)
        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(IDictionary<string, object> parameters)
        {
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam<T>(T parameters)
        {
            return this.Tokens.AccessApi<UserResponse, T>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(string screen_name)
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <returns>The user.</returns>
        public UserResponse ReportSpam(long user_id)
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApi<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        #endif
        #if !NET35

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(params Expression<Func<string, object>>[] parameters)
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(IDictionary<string, object> parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// <para>Available parameters:</para>
        /// <para>- <c>string</c> screen_name (any one is required)</para>
        /// <para>- <c>long</c> user_id (any one is required)</para>
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync<T>(T parameters, CancellationToken cancellationToken = default(CancellationToken))
        {
            return this.Tokens.AccessApiAsync<UserResponse, T>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="screen_name">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(string screen_name, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            if(screen_name == null) throw new ArgumentNullException("A required argument 'screen_name' must not be null");
            else parameters.Add("screen_name", screen_name);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        /// <summary>
        /// <para>Report the specified user as a spam account to Twitter.</para>
        /// <para>Additionally performs the equivalent of POST blocks/create on behalf of the authenticated user.</para>
        /// <para>Note: One of these parameters must be provided.</para>
        /// </summary>
        /// <param name="user_id">any one is required.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>The user.</returns>
        public Task<UserResponse> ReportSpamAsync(long user_id, CancellationToken cancellationToken = default(CancellationToken))
        {
            var parameters = new Dictionary<string, object>();
            parameters.Add("user_id", user_id);
            return this.Tokens.AccessApiAsync<UserResponse>(MethodType.Post, "users/report_spam", parameters, cancellationToken);
        }

        #endif

    }

}
